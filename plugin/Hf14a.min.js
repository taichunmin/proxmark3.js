!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("lodash")):"function"==typeof define&&define.amd?define(["lodash"],e):(t="undefined"!=typeof globalThis?globalThis:t||self).Pm3Hf14a=e(t._)}(this,(function(t){"use strict";function e(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var r=e(t);class a extends Uint8Array{constructor(...t){super(...t),this.dv=new DataView(this.buffer,this.byteOffset,this.length)}static fromView(t){if(!ArrayBuffer.isView(t))throw new TypeError("invalid view");return new a(t.buffer,t.byteOffset,t.byteLength)}static fromHex(t,e=!1){const n=t.replace(/[^0-9A-Fa-f]/g,"").match(/.{2}/g);return e&&n.reverse(),new a(r.default.map(n,(t=>r.default.parseInt(t,16))))}static fromUtf8(t){return a.fromView((new TextEncoder).encode(t))}static merge(...t){if(t.length<2)return t.length?t[0]:new a;const e=r.default.sumBy(t,"length"),n=new a(e);return r.default.reduce(t,((t,e)=>(n.set(e,t),t+e.length)),0),n}static isLen(t,e=null){return t instanceof a&&(r.default.isNil(e)||t.length===e)}isEqual(t){return this.length===t.length&&this.every(((e,r)=>e===t[r]))}chunk(t){if(t<1)throw new TypeError("invalid bytesPerChunk");const e=[];for(let r=0;r<this.length;r+=t)e.push(this.subarray(r,r+t));return e}get hex(){return r.default.map(this,(t=>(t+256).toString(16).slice(-2))).join("").toUpperCase()}get rhex(){return r.default.map(this,(t=>(t+256).toString(16).slice(-2))).reverse().join("").toUpperCase()}get inspect(){return`${r.default.map(this,(t=>(t+256).toString(16).slice(-2))).join(" ").toUpperCase()} (len=${this.length})`}get utf8(){return(new TextDecoder).decode(this)}get base64url(){const t=[];for(let e=0;e<this.length;e+=3){let a=0;for(let t=0;t<3;t++)a|=(e+t<this.length?this[e+t]:0)<<16-8*t;t.push(r.default.times(Math.min(this.length-e+1,4),(t=>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"[a>>18-6*t&63])).join(""))}return t.join("")}dvGetter(t,e,r=!0){return e<0&&(e+=this.dv.byteLength),this.dv[t](e,r)}getBigInt64(...t){return this.dvGetter("getBigInt64",...t)}getBigUint64(...t){return this.dvGetter("getBigUint64",...t)}getFloat32(...t){return this.dvGetter("getFloat32",...t)}getFloat64(...t){return this.dvGetter("getFloat64",...t)}getInt16(...t){return this.dvGetter("getInt16",...t)}getInt32(...t){return this.dvGetter("getInt32",...t)}getInt8(...t){return this.dvGetter("getInt8",...t)}getUint16(...t){return this.dvGetter("getUint16",...t)}getUint32(...t){return this.dvGetter("getUint32",...t)}getUint8(...t){return this.dvGetter("getUint8",...t)}dvSetter(t,e,r,a=!0){return e<0&&(e+=this.dv.byteLength),this.dv[t](e,r,a),this}setBigInt64(...t){return this.dvSetter("setBigInt64",...t)}setBigUint64(...t){return this.dvSetter("setBigUint64",...t)}setFloat32(...t){return this.dvSetter("setFloat32",...t)}setFloat64(...t){return this.dvSetter("setFloat64",...t)}setInt16(...t){return this.dvSetter("setInt16",...t)}setInt32(...t){return this.dvSetter("setInt32",...t)}setInt8(...t){return this.dvSetter("setInt8",...t)}setUint16(...t){return this.dvSetter("setUint16",...t)}setUint32(...t){return this.dvSetter("setUint32",...t)}setUint8(...t){return this.dvSetter("setUint8",...t)}getUint24(t,e=!0){const[r,a]=e?[t+2,t]:[t,t+1];return this.getUint8(r)<<16|this.getUint16(a,e)}setUint24(t,e,r=!0){const[a,n]=r?[t+2,t]:[t,t+1];return this.setUint8(a,e>>16&255),this.setUint16(n,65535&e,r),this}getInt24(t,e=!0){const r=this.getUint24(t,e);return r-(r>8388607?16777216:0)}setInt24(t,e,r=!0){return this.setUint24(t,16777215&e,r)}}const n={ARC:32773,CCITT:4129,CDMA2000:51303,DECT:1417,DNP:15717,KERMIT:33800,LEGIC_16:45,LEGIC:50886,T10_DIF:35767,TELEDISK:41111},i={},s=t=>{if(!i.reflect8){const t=i.reflect8=new a(256);for(let e=0;e<256;e++){let r=e;r=(240&r)>>4|(15&r)<<4,r=(204&r)>>2|(51&r)<<2,r=(170&r)>>1|(85&r)<<1,t[e]=r}}return i.reflect8[255&t]},o=t=>s(t>>8)|s(t)<<8,c=t=>new a([255&t,t>>8&255]),d=(t,e,c,d,l)=>{if(!a.isLen(t))throw new TypeError("invalid data");if(!t.length)return~c;const u=((t,e)=>{const a=`${t}${e?1:0}`;if(!r.default.hasIn(i,`poly.${a}`)){const c=new Uint16Array(256);for(let r=0;r<256;r++){let a=(e?s(r):r)<<8,i=0;for(let e=0;e<8;e++)i=(32768&(i^a)?n[t]:0)^i<<1,a=a<<1&65535;c[r]=e?o(i):i}r.default.set(i,`poly.${a}`,c)}return i.poly[a]})(e,d);if(d){c=o(c);for(const e of t)c=c>>8^u[255&c^e];return l?c:o(c)}c&=65535;for(const e of t)c=(255&c)<<8^u[c>>8^e];return l?o(c):c},l=t=>c(d(t,"CCITT",50886,!0,!0));return class{constructor(){this.name="hf14a"}install(t,e){const{Packet:a,pm3:n,PM3_CMD:i,utils:{retry:s}}=t,o=t=>{const e=r.default.flatten(r.default.times(3,(e=>[(240&t[e])>>4,15&t[e]])));return r.default.every([[1,2],[0,5],[3,4]],(([t,r])=>e[t]^15===e[r]))},u=t=>{if(!r.default.isArray(t))throw new TypeError("invalid keys");return r.default.chain(t).filter((t=>a.isLen(t,6))).uniqWith(((t,e)=>t.isEqual(e))).value()},f=async()=>{n.clearRespBuf(),await n.sendCommandNG({cmd:i.HF_DROPFIELD})},w=async()=>{await n.sendCommandMix({cmd:i.HF_ISO14443A_READER})},h=async()=>{await f(),n.clearRespBuf(),await n.sendCommandMix({cmd:i.HF_ISO14443A_READER,arg:[0b11n]});const t=await n.readRespTimeout(i.ACK);if(t.selectStatus=Number(t.getArg(0)),t.card={atqa:t.data.subarray(11,13),ats:t.data.subarray(15,15+t.data(10)),sak:t.data.subarray(13,14),uid:t.data.subarray(t.data[10])},0===t.selectStatus)throw new Error("failed to select iso14443a card");if(3===t.selectStatus)throw new Error(`Card doesn't support standard iso14443-3 anticollision, ATQA: ${t.card.atqa.hex}`);return t.card},y=async({block:t=0,isKb:e=0,key:r}={})=>{if(!a.isLen(r,6))throw new TypeError("invalid key");e=e?1:0,n.clearRespBuf(),await n.sendCommandNG({cmd:i.HF_MIFARE_CHKKEYS,data:new a([e,t,1,0,1])});const s=await n.readRespTimeout(i.HF_MIFARE_CHKKEYS);if(s.status&&!s.data[6])throw new Error(`Failed to auth block ${t}`);return s.data.subarray(0,6)},m=async({block:t=0,isKb:e=0,key:r}={})=>{if(!a.isLen(r,6))throw new TypeError("invalid key");return e=e?1:0,await s((async()=>{n.clearRespBuf(),await n.sendCommandNG({cmd:i.HF_MIFARE_READBL,data:new a([t,e,...r])});const s=await n.readRespTimeout(i.HF_MIFARE_READBL);if(s.status)throw new Error(`Failed to read block ${t}`);return s.data}))},g=async({sector:t=0,ka:e,kb:r}={})=>{const n=new a(64),i={key:[0,0],read:[0,0,0,0]};for(let a=1;a>=0;a--)try{const s=[e,r][a];await y({block:4*t,isKb:a,key:s}),i.key[a]=1;for(let e=0;e<4;e++)try{if(i.read[e])continue;const r=await m({block:4*t+e,isKb:a,key:s});n.set(r,16*e),i.read[e]=1}catch(t){}}catch(t){}for(let t=1;t>=0;t--)i.key[t]&&n.set([e,r][t],[48,58][t]);return{data:n,success:i.read}},k=async({block:t=0,isKb:e=0,key:r,data:o}={})=>{if(!a.isLen(r,6))throw new TypeError("invalid key");if(!a.isLen(o,16))throw new TypeError("invalid data");e=e?1:0,await s((async()=>{n.clearRespBuf(),await n.sendCommandMix({cmd:i.HF_MIFARE_WRITEBL,arg:[t,e],data:new a([...r,0,0,0,0,...o])});const s=await n.readRespTimeout(i.ACK);if(!(255&Number(s.getArg(0))))throw new Error(`Failed to write block ${t}`)}))},E=async({sector:t=0,ka:e,kb:r,data:n}={})=>{if(!a.isLen(n,64))throw new TypeError("invalid data");if(!o(n.subarray(54,57)))throw new TypeError("invalid sector acl");const i=[0,0,0,0];for(let a=1;a>=0;a--){const s=[e,r][a];for(let e=0;e<4;e++)if(!i[e])try{await k({block:4*t+e,isKb:a,key:s,data:n.subarray(16*e,16*e+16)}),i[e]=1}catch(t){}}return i},p=async({block:t=0}={})=>await s((async()=>{n.clearRespBuf(),await n.sendCommandMix({cmd:i.HF_MIFARE_CGETBL,arg:[30,t]});const e=await n.readRespTimeout(i.ACK);if(!(255&Number(e.getArg(0))))throw new Error(`Failed to write block ${t}`);return e.data.slice(0,16)})),b=async({block:t,data:e,wipe:r=!1}={})=>{if(!a.isLen(e,16))throw new TypeError("invalid data");const o=30|(r?64:0);await s((async()=>{n.clearRespBuf(),await n.sendCommandMix({cmd:i.HF_MIFARE_CSETBL,arg:[o,t],data:e});const r=await n.readRespTimeout(i.ACK);if(!(255&Number(r.getArg(0))))throw new Error(`Failed to write block ${t}`);return r.data.slice(0,4)}))},v=async({block:t=0}={})=>await s((async()=>{n.clearRespBuf(),await n.sendCommandNG({cmd:i.HF_MIFARE_EML_MEMGET,data:new a([t,1])});const e=await n.readRespTimeout(i.HF_MIFARE_EML_MEMGET);if(e.status)throw new Error("Failed to read block from eml");return e.data})),T=async({block:t=0,data:e}={})=>{if(!a.isLen(e,16))throw new TypeError("invalid data");await s((async()=>{n.clearRespBuf(),await n.sendCommandNG({cmd:i.HF_MIFARE_EML_MEMSET,data:new a([t,1,16,...e])})}))},R=async({keys:t,sectorMax:e=16}={})=>{const s={*[Symbol.iterator](){if(!t)return void(yield{arg:[4352|e,257,0]});if(!(t=u(t)).length)throw new TypeError("invalid keys");const r=a.merge(...t).chunk(510);for(const t of[1,2])for(let a=0;a<r.length;a++){const n=r[a];yield{data:n,arg:[(a+1===r.length)<<12|(0===a)<<8|e,t,n.length/6]}}}};let o;for(const t of s)if(n.clearRespBuf(),await n.sendCommandOLD({cmd:i.HF_MIFARE_CHKKEYS_FAST,...t}),o=await n.readRespTimeout(i.ACK,36e4),Number(o.getArg(0))===2*e)break;const c={flags:new a(r.default.map([7,6,5,4,3,2,1,0,8,9],(t=>o.data[480+t]))),keys:[]};for(let t=0;t<e;t++)for(const e of[2*t,2*t+1]){const t=c.flags[e>>3]>>(7&e)&1;c.keys[e]=t?o.data.subarray(6*e,6*e+6):null}return c.keys};return{cardInfo:async()=>{try{return await h()}finally{await w()}},deselectCard:w,dropField:f,mfAuthBlock:y,mfEmlReadBlock:v,mfEmlReadCard:async({sectorMax:t=16}={})=>{const e=new a(64*t);for(let r=0;r<4*t;r++)try{const t=await v({block:r});e.set(t,16*r)}catch(t){}return e},mfEmlReadSector:async({sector:t=0}={})=>{const e=new a(64);for(let r=0;r<4;r++)try{const a=await v({block:4*t+r});e.set(a,16*r)}catch(t){}return e},mfEmlWriteBlock:T,mfEmlWriteCard:async({sectorMax:t=16,data:e}={})=>{if(!a.isLen(e,64*t))throw new TypeError("invalid data");for(let r=0;r<4*t;r++)try{await T({block:r,data:e.subarray(16*r,16*r+16)})}catch(t){}},mfEmlWriteSector:async({sector:t=0,data:e}={})=>{if(!a.isLen(e,64))throw new TypeError("invalid data");for(let r=0;r<4;r++)try{await T({block:4*t+r,data:e.subarray(16*r,16*r+16)})}catch(t){}},mfKeysCheck:R,mfKeysUniq:u,mfReadBlock:m,mfReadBlockGen1a:p,mfReadBlockKeyBA:async({block:t=0,ka:e,kb:r}={})=>{for(let a=1;a>=0;a--)try{return await m({block:t,isKb:a,key:[e,r][a]})}catch(t){}throw new Error(`Failed to read block ${t}`)},mfReadCardByKeys:async({keys:t,sectorMax:e=16}={})=>{if(!(t=u(t)).length)throw new TypeError("invalid keys");const r=[],n=await R({keys:t,sectorMax:e}),i=new a(64*e);for(let t=0;t<e;t++){const e=await g({sector:t,ka:n[2*t],kb:n[2*t+1]});i.set(e.data,64*t),r.push(...e.success)}return{data:i,success:r}},mfReadCardGen1a:async({sectorMax:t=16}={})=>{const e=new a(64*t),n=r.default.times(4*t,(()=>0));for(let r=0;r<4*t;r++)try{e.set(await p({block:r}),16*r),n[r]=1}catch(t){}return{data:e,success:n}},mfReadSector:async({sector:t=0,isKb:e=0,key:r}={})=>{if(!a.isLen(r,6))throw new TypeError("invalid key");return e=e?1:0,await s((async()=>{n.clearRespBuf(),await n.sendCommandMix({cmd:i.HF_MIFARE_READSC,arg:[t,e],data:r});const a=await n.readRespTimeout(i.ACK);if(!(255&Number(a.getArg(0))))throw new Error(`Failed to read sector ${t}`);return a.data.slice(0,64)}))},mfReadSectorGen1a:async({sector:t=0}={})=>{const e=new a(64),r=[0,0,0,0];for(let t=0;t<4;t++)try{e.set(await p({block:t}),16*t),r[t]=1}catch(t){}return{data:e,success:r}},mfReadSectorKeyBA:g,mfSimulateCard:async({type:t="1k",uid:e,atqa:s,sak:o,exitAfter:c=0,interactive:d=!1,nrArAttack:l=!1,emukeys:u=!1,cve:f=!1}={})=>{const w=new a(16);let h=0;if(e){if(!a.isLen(e))throw new TypeError("invalid uid");if(!r.default.includes([4,7,10],e.length))throw new TypeError("invalid uid");w.set(e,3),h|=1<<r.default.floor(e.length/3)}else h|=16;if(s){if(!a.isLen(s,2))throw new TypeError("invalid atqa");w.set(s,13),h|=2048}if(o){if(!a.isLen(o,1))throw new TypeError("invalid sak");w.set(o,15),h|=4096}d&&(h|=1),l&&(h|=32),f&&(h|=8192);const y={mini:128,"1k":256,"2k":512,"4k":1024};if(!y[t=r.default.toLower(t)])throw new TypeError("invalid type");if(h|=y[t],w.setUint16(0,h),w.setUint8(2,c),n.clearRespBuf(),await n.sendCommandNG({cmd:i.HF_MIFARE_SIMULATE,data:w}),d)for(;;){const t=await n.readRespTimeout(i.ACK);if(!l)break;if((65535&Number(t.getArg(0)))!==i.HF_MIFARE_SIMULATE)break;console.log("nrArAttack",t)}},mfWriteBlock:k,mfWriteBlockGen1a:b,mfWriteBlockKeyBA:async({block:t=0,ka:e,kb:r,data:a}={})=>{for(let n=1;n>=0;n--)try{await k({block:t,isKb:n,key:[e,r][n],data:a})}catch(t){}throw new Error(`Failed to write block ${t}`)},mfWriteCardByKeys:async({sectorMax:t=16,keys:e,data:r}={})=>{if(!a.isLen(r,64*t))throw new TypeError("invalid data");if(!(e=u(e)).length)throw new TypeError("invalid keys");const n=await R({sectorMax:t,keys:e}),i=[];for(let e=0;e<t;e++){let t=[0,0,0,0];try{t=await E({data:r.subarray(64*e,64*(e+1)),ka:n[2*e],kb:n[2*e+1],sector:e})}catch(t){}i.push(...t)}return i},mfWriteCardGen1a:async({sectorMax:t=16,data:e}={})=>{if(!a.isLen(e,64*t))throw new TypeError("invalid data");const n=e.chunk(16),i=r.default.times(4*t,(()=>0));for(let t=0;t<n.length;t++)try{await b({block:t,data:n[t]}),i[t]=1}catch(t){}return i},mfWriteSector:async({sector:t=0,isKb:e,key:r,data:n}={})=>{if(!a.isLen(n,64))throw new TypeError("invalid data");if(!o(n.subarray(54,57)))throw new TypeError("invalid sector acl");const i=[0,0,0,0];for(let a=0;a<4;a++)try{await k({block:4*t+a,isKb:e,key:r,data:n.subarray(16*a,16*a+16)}),i[a]=1}catch(t){}return i},mfWriteSectorGen1a:async({sector:t=16,data:e}={})=>{if(!a.isLen(e,64))throw new TypeError("invalid data");const r=e.chunk(16),n=[0,0,0,0];for(let e=0;e<r.length;e++)try{await b({block:4*t+e,data:r[e]}),n[e]=1}catch(t){}return n},mfWriteSectorKeyBA:E,selectCard:h,sendRaw:async({active:t=0,crc:e=!1,data:s=new a,disconnect:o=!0,ecp:u=!1,magsafe:f=!1,numbits:w=0,rats:h=!0,reply:y=!0,timeout:m=0,topaz:g=!1}={})=>{if(!a.isLen(s))throw new TypeError("invalid data type");if(s.length>=512)throw new TypeError("invalid data length");if(e){if(s.length>=510)throw new TypeError("failed to add CRC");s.length>0&&(s=a.merge(s,g?(t=>c(65535^d(t,"CCITT",65535,!0,!0)))(s):l(s)))}let k=[0,1,129]?.[t];if(m>0&&(k|=64,m=r.default.floor(10.59375*Math.min(m,40542464))),o||(k|=2),s.length&&(k|=8),g&&(k|=256),h||(k|=512),u&&(k|=2048),f&&(k|=4096),n.clearRespBuf(),await n.sendCommandOLD({cmd:i.HF_ISO14443A_READER,arg:[k,s.length|w<<16,m],data:s}),!y)return;if(1===t){const t=await n.readRespTimeout(i.ACK,m+2500);if(t.uidlen=65535&Number(t.getArg(1)),!t.uidlen)throw new Error("Failed to select card")}if(!s.length)return;const E=await n.readRespTimeout(i.ACK,m+2500);if(E.datalen=65535&Number(E.getArg(0)),!E.datalen)throw new Error("Failed to receive data");const p=E.data.subarray(0,-2);return E.datalen>=3&&l(p).isEqual(E.data.subarray(-2))&&(E.dataWithoutCrc=p),E}}}}}));
